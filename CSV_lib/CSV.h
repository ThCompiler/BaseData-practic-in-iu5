//! @file
//! \brief Реализация базовой работы с csv таблицами
//===========================================================================================================
//! @mainpage
//! Библиотека для работы с таблицами в формате csv <br>
//! Задание практики 2 семестра 1 курса ИУ5 
//!
//! \author <p> Ветошкин Артём -- <i> 1 курс ИУ5 МГТУ им. Баумана </i> </p>
//!
//! \date Marth - April 2020
//===========================================================================================================

#pragma once
#include <string>
#include <vector>
#include <unordered_map>
#include <iostream>
#include <fstream>
#include <stdexcept>
#include <variant>


namespace csv_format /// пространства имён базового класса работы с csv таблицами
{
//===============================================================================================================
//! \brief Доступные типы хранения данных в таблицы
//---------------------------------------------------------------------------------------------------------------

    enum class parsing_type {
        String,     ///< Строковый тип: std::string
        NoType      ///< Неопределённый тип
    };

//===============================================================================================================
//! \class Column_header
//! \brief Класс столбца талблицы в CSV
//! \warning Любой другой класс для столбца обязан быть наследником данного или содержать такие же поля
//---------------------------------------------------------------------------------------------------------------

    struct Column_header
    {
        size_t _id;             ///< порядковый номер столбца в таблице
        std::string _name;      ///< имя стобца
        parsing_type _type;     ///< тип хранения данных в столбце

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Конструктор по-умолчанию
    //-----------------------------------------------------------------------------------------------------------

        Column_header();

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Консруктор по полям
    //!
    //! \param name         название столбца
    //! \param id           порядковый номер столбца в таблице
    //! \param tmp_type     тип данных хранимых в столбце
    //-----------------------------------------------------------------------------------------------------------

        Column_header(std::string name, size_t id, parsing_type tmp_type = parsing_type::NoType);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Консруктор из файла
    //!
    //! \param in           файловый поток
    //-----------------------------------------------------------------------------------------------------------

        Column_header(std::ifstream& in);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Перегрузка оператора ввода из файл
    //!
    //! \param in           файловый поток
    //! \param header       вводимый объект класса
    //-----------------------------------------------------------------------------------------------------------

        friend
            std::ifstream& operator>>(std::ifstream& in, Column_header& header);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Перегрузка оператора вывода в файл
    //!
    //! \param out          файловый поток
    //! \param header       выводимый объект класса
    //-----------------------------------------------------------------------------------------------------------

        friend
            std::ofstream& operator<<(std::ofstream& out, Column_header& header);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Загружает уровень из xml файла загрузки
    //!
    //! \param separator    разделитель при записи данных о столбце в файл
    //-----------------------------------------------------------------------------------------------------------

        static void set_separator(char separator = '|');

    protected:
        static char _separator;     ///< разделитель при записи данных о столбце в файл
    };

//===============================================================================================================
//! \class TestElement
//! \brief Элемент таблицы
//!
//! \warning Любой другой класс для элементов обязан быть наследником данного или содержать такие же поля и методы
//---------------------------------------------------------------------------------------------------------------

    class TestElement
    {
    public:
        typedef std::variant<bool, std::string> types;  ///< тип данных, в котором хранитмя значение элемента таблицы

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Конструктор по-умолчанию
    //-----------------------------------------------------------------------------------------------------------

        TestElement();

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Консруктор с получением значения
    //!
    //! \param type         тип хранимых данных
    //! \param value        значение ячейки, которое будет преобразованно в соответствуюший тип
    //-----------------------------------------------------------------------------------------------------------

        TestElement(parsing_type type, std::string value);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Установка значения элемента таблицы
    //!
    //! \param type         тип хранимых данных
    //! \param value        значение ячейки, соответствующего типа
    //-----------------------------------------------------------------------------------------------------------

        virtual void set(parsing_type type, std::string value);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Получение значения элемента таблицы
    //!
    //! \return указатель на значение элемента соответствующего типа
    //-----------------------------------------------------------------------------------------------------------

        virtual const void* get() const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief ПОлучение значения элемента таблицы, как строки
    //!
    //! \return строка со значением элемента
    //-----------------------------------------------------------------------------------------------------------

        virtual std::string as_string() const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор меньше
    //!
    //! \param el           объект класса, с ктороым сравниваем
    //!
    //! \return результат сравнения
    //-----------------------------------------------------------------------------------------------------------

        virtual bool operator<(const TestElement& el) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор меньше или равно
    //!
    //! \param el           объект класса, с ктороым сравниваем
    //!
    //! \return результат сравнения
    //-----------------------------------------------------------------------------------------------------------

        virtual bool operator<=(const TestElement& el) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор больше
    //!
    //! \param el           объект класса, с ктороым сравниваем
    //!
    //! \return результат сравнения
    //-----------------------------------------------------------------------------------------------------------

        virtual bool operator>(const TestElement& el) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор больше или равно
    //!
    //! \param el           объект класса, с ктороым сравниваем
    //!
    //! \return результат сравнения
    //-----------------------------------------------------------------------------------------------------------

        virtual bool operator>=(const TestElement& el) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор равенства
    //!
    //! \param el           объект класса, с ктороым сравниваем
    //!
    //! \return результат сравнения
    //-----------------------------------------------------------------------------------------------------------

        virtual bool operator==(const TestElement& el) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор не равенства
    //!
    //! \param el           объект класса, с ктороым сравниваем
    //!
    //! \return результат сравнения
    //-----------------------------------------------------------------------------------------------------------

        virtual bool operator!=(const TestElement& el) const;

    private:
        types _value;           ///<    значение элемента
        parsing_type _type;     ///<    тип хранимого значения
    };

//===============================================================================================================
//! \class CSV_table
//! \brief Класс для получения и работы с таблицами, хранимыми в формате CSV
//---------------------------------------------------------------------------------------------------------------

    template<class Elements = TestElement, class Column_Header = Column_header>
    class CSV_table
    {
    public:
        typedef std::unordered_map<std::string, Column_Header> Header;  ///< тип заголовка таблицы
        typedef std::vector<Elements> Row;                              ///< тип строки таблицы

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Конструктор по-умолчанию
    //!
    //! \param separator    разделить данных в таблице
    //-----------------------------------------------------------------------------------------------------------

        CSV_table(char separator = '|');

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Конструктор из файла
    //!
    //! \param in           файловый поток
    //! \param separator    разделить данных в таблице
    //-----------------------------------------------------------------------------------------------------------

        CSV_table(std::ifstream& in, char separator = '|');

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Функция получения заголовка
    //!
    //! \return заголовок
    //-----------------------------------------------------------------------------------------------------------

        virtual Header get_header() const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Функция получения уникального ключа таблицы
    //!
    //! \return уникальный ключ
    //-----------------------------------------------------------------------------------------------------------

        virtual std::string get_key() const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Функция получения имени таблицы
    //!
    //! \return имя таблицы
    //-----------------------------------------------------------------------------------------------------------

        virtual std::string get_name() const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Функция получения таблиц значений без заголовка
    //!
    //! \return таблица
    //-----------------------------------------------------------------------------------------------------------

        virtual const std::vector<Row>& get_table() const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Добавляет строку в конец
    //!
    //! \param row          новая строка
    //-----------------------------------------------------------------------------------------------------------

        void push_row(const Row& row);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Устанавливает заданный заголовок
    //!
    //! \param header       новый заголовок
    //-----------------------------------------------------------------------------------------------------------

        virtual void set_header(Header& header);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Удаляет строку
    //!
    //! \param id           порядковый номер строки
    //-----------------------------------------------------------------------------------------------------------

        virtual void delete_row(size_t id);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Удаляет столбец
    //!
    //! \param name         имя столбца
    //-----------------------------------------------------------------------------------------------------------

        virtual void delete_column(std::string name);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор индексации
    //!
    //! \param id           порядковый номер строки
    //-----------------------------------------------------------------------------------------------------------

        virtual Row& operator[](size_t id);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор индексации константной таблицы
    //!
    //! \param id           порядковый номер строки
    //-----------------------------------------------------------------------------------------------------------

        virtual const Row& operator[](size_t id) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор доступа к элементу по имени столбца и номеру строки
    //!
    //! \param attribute    имя столбца
    //! \param i            порядковый номер строки
    //-----------------------------------------------------------------------------------------------------------

        virtual Elements& operator()(std::string attribute, size_t i);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор доступа к элементу по имени столбца и номеру строки для константной таблицы
    //!
    //! \param attribute    имя столбца
    //! \param i            порядковый номер строки
    //-----------------------------------------------------------------------------------------------------------

        virtual const Elements& operator()(std::string attribute, size_t i) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Получения числа строк в таблице
    //!
    //! \return     число строк в таблице
    //-----------------------------------------------------------------------------------------------------------

        size_t height() const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Получения числа столбцов в таблице
    //!
    //! \return     число столбцов в таблице
    //-----------------------------------------------------------------------------------------------------------

        size_t width() const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Перегрузка оператора ввода из файла
    //!
    //! \param in           файловый поток
    //! \param table        вводимый объект класса
    //-----------------------------------------------------------------------------------------------------------

        template<class Elements, class Column_Header>
        friend
            std::ifstream& operator>>(std::ifstream& in, CSV_table<Elements, Column_Header>& table);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Перегрузка оператора вывода в файла
    //!
    //! \param out           файловый поток
    //! \param table        выводимый объект класса
    //-----------------------------------------------------------------------------------------------------------

        template<class Elements, class Column_Header>
        friend
            std::ofstream& operator<<(std::ofstream& out, const CSV_table<Elements, Column_Header>& table);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Читает данные до разделителя
    //!
    //! \param in           файловый поток
    //! \param separator    разделить
    //-----------------------------------------------------------------------------------------------------------

        static std::string read_before_separator(std::ifstream& in, char separator = '|');

    protected:
        Header _columns_header;     ///<    заголовк таблицы
        std::vector<Row> _date;     ///<    таблицы

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Запись из файла таблицы
    //!
    //! \param out          файловый поток
    //-----------------------------------------------------------------------------------------------------------

        virtual void write_to_file(std::ofstream& out) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Чтения из файла таблицы
    //!
    //! \param in           файловый поток
    //-----------------------------------------------------------------------------------------------------------

        virtual void read_from_file(std::ifstream& in);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Обновления типов хранения значений в таблице
    //-----------------------------------------------------------------------------------------------------------

        virtual void reparsing();

    private:
        std::string _name;      ///<    имя таблицы
        std::string _key;       ///<    ункиальный ключ таблицы

        char _separator;        ///<    разделитель данных таблицы
    };

//=================================================================================================================

    template<class Elements, class Column_Header>
    inline CSV_table<Elements, Column_Header>::CSV_table(char separator)
        : _separator(separator) {}

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline CSV_table<Elements, Column_Header>::CSV_table(std::ifstream& in, char separator)
        : _separator(separator)
    {
        in >> *this;
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline typename CSV_table<Elements, Column_Header>::Header CSV_table<Elements, Column_Header>::get_header() const
    {
        return _columns_header;
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline std::string CSV_table<Elements, Column_Header>::get_key() const
    {
        return _key;
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline std::string CSV_table<Elements, Column_Header>::get_name() const
    {
        return _name;
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline const std::vector<typename CSV_table<Elements, Column_Header>::Row>& CSV_table<Elements, Column_Header>::get_table() const
    {
        return _date;
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline void CSV_table<Elements, Column_Header>::push_row(const Row& row)
    {
        _date.push_back(row);
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline void CSV_table<Elements, Column_Header>::set_header(CSV_table<Elements, Column_Header>::Header& header)
    {
        _columns_header = header;
        reparsing();
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline void CSV_table<Elements, Column_Header>::delete_row(size_t id)
    {
        if (id >= _date.size())
        {
            return;
        }

        _date.erase(_date.begin() + (const int)id);
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline void CSV_table<Elements, Column_Header>::delete_column(std::string name)
    {
        if (_columns_header.find(name) == _columns_header.end())
        {
            return;
        }

        size_t id = _columns_header[name]._id;
        for (size_t i = 0; i < _date.size(); ++i)
        {
            _date[i].erase(_date[i].begin() + (const int)id);
        }
        _columns_header.erase(name);
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline typename CSV_table<Elements, Column_Header>::Row& CSV_table<Elements, Column_Header>::operator[](size_t id)
    {
        if (id >= _date.size())
        {
            throw std::out_of_range("End of table");
        }
        return _date[id];
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline const typename CSV_table<Elements, Column_Header>::Row& CSV_table<Elements, Column_Header>::operator[](size_t id) const
    {
        if (id >= _date.size())
        {
            throw std::out_of_range("End of table");
        }
        return _date[id];
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline Elements& CSV_table<Elements, Column_Header>::operator()(std::string attribute, size_t i)
    {
        if (i >= _date.size() || _columns_header.find(attribute) == _columns_header.end())
        {
            throw std::out_of_range("End of table");
        }
        return _date[i][_columns_header[attribute]._id];
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline const Elements& CSV_table<Elements, Column_Header>::operator()(std::string attribute, size_t i) const
    {
        Header tmp = _columns_header;
        if (i >= _date.size() || _columns_header.find(attribute) == _columns_header.end())
        {
            throw std::out_of_range("End of table");
        }
        return _date[i][tmp[attribute]._id];
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline size_t CSV_table<Elements, Column_Header>::height() const
    {
        return _date.size();
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline size_t CSV_table<Elements, Column_Header>::width() const
    {
        return _columns_header.size();
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline std::string CSV_table<Elements, Column_Header>::read_before_separator(std::ifstream& in, char separator)
    {
        char tmp = '\0';
        bool open = false;
        std::string str = "";
        while (in.get(tmp))
        {
            if (tmp == '\"' && str.size() == 0)
            {
                str += tmp;
                open = true;
                continue;
            }

            if (tmp == separator || tmp == '\n')
            {
                if ((isblank(tmp) || tmp == '\n') && str.size() == 0)
                {
                    continue;
                }

                if (!open)
                {
                    if (tmp == '\n') {
                        in.putback(tmp);
                    }
                    return str;
                }

                for (long i = (long)str.size() - 1; i >= 0; --i)
                {
                    if (!isblank(str[i]) && str[i] != '\"')
                    {
                        break;
                    }
                    if (str[i] == '\"') {
                        for (long j = i + 1; j < (long)str.size(); str.pop_back(), ++j) {}

                        if (tmp == '\n')
                        {
                            in.putback(tmp);
                        }
                        return str;
                    }
                }
            }

            str += tmp;
        }

        return str;
    }

 //-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline void CSV_table<Elements, Column_Header>::write_to_file(std::ofstream& out) const
    {
        out << _name << _separator << _key << "\n";

        size_t k = 0;
        std::vector<size_t> columns_id(_columns_header.size());

        for (auto column : _columns_header)
        {
            out << column.second;
            columns_id[k++] = column.second._id;

            if (k != _columns_header.size())
            {
                out << _separator;
            }
        }
        out << "\n";

        for (size_t i = 0; i < _date.size(); ++i)
        {
            for (size_t j = 0; j < _date[i].size(); ++j)
            {
                out << _date[i][columns_id[j]].as_string();
                if (j + 1 != columns_id.size())
                {
                    out << _separator;
                }
            }
            out << "\n";
        }
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline void CSV_table<Elements, Column_Header>::read_from_file(std::ifstream& in)
    {
        _name = CSV_table<>::read_before_separator(in, _separator);
        _key = CSV_table<>::read_before_separator(in, _separator);

        char ch = '\0';
        size_t id = 0;
        Column_Header::set_separator(_separator);
        while (ch != '\n')
        {
            Column_Header tmp(in);
            tmp._id = id++;

            _columns_header[tmp._name] = tmp;

            in.get(ch);
            if (ch != '\n')
            {
                in.putback(ch);
            }
        }
        typename CSV_table<Elements, Column_Header>::Row tmp(_columns_header.size());
        while (in.get(ch)) {
            in.putback(ch);

            for (size_t i = 0; i < tmp.size(); ++i) {
                std::string tmp_str = CSV_table<>::read_before_separator(in, _separator);

                if (tmp_str.size() == 0)
                {
                    return;
                }

                for (auto column : _columns_header) 
                {
                    if (column.second._id == i)
                    {
                        tmp[i].set(column.second._type, tmp_str);
                        break;
                    }
                }
            }

            _date.push_back(tmp);
        }

    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements, class Column_Header>
    inline void CSV_table<Elements, Column_Header>::reparsing()
    {
        for (auto column : _columns_header) {
            for (size_t i = 0; i < _date.size(); ++i)
            {
                _date[i][column.second._id].set(column.second._type, _date[i][column.second._id].as_string());
            }
        }
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements = TestElement, class Column_Header = Column_header>
    std::ifstream& operator>>(std::ifstream& in, CSV_table<Elements, Column_Header>& table)
    {
        table.read_from_file(in);
        return in;
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class Elements = TestElement, class Column_Header = Column_header>
    std::ofstream& operator<<(std::ofstream& out, const CSV_table<Elements, Column_Header>& table)
    {
        table.write_to_file(out);
        return out;
    }
}