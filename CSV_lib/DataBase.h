//! @file
//! \brief Реализация базовой работы с таблицой соглассно заданию
//===========================================================================================================

#pragma once
#include <iomanip>
#include <algorithm>
#include "CSV.h"
#include "Parse.h"
#include "Time.h"
#include <variant>


namespace DB    /// пространство имён классов и функция для задания
{
//===============================================================================================================
//! \class Column
//! \brief Класс столбца таблицы
//---------------------------------------------------------------------------------------------------------------

	struct Column : public csv_format::Column_header
	{
		size_t _out_lenght;     ///< длина выводимых значений данного столбца
        parsing_type _type;     ///< тип хранения данных в столбце

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Конструктор по-умолчанию
    //-----------------------------------------------------------------------------------------------------------  

		Column();

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Консруктор по полям
    //!
    //! \param name         название столбца
    //! \param id           порядковый номер столбца в таблице
    //! \param type         тип данных хранимых в столбце
    //! \param out_lenght   длина выводимых значений данного столбца
    //-----------------------------------------------------------------------------------------------------------

		Column(std::string name, size_t id, parsing_type type, size_t out_lenght);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Консруктор из файла
    //!
    //! \param in           файловый поток
    //-----------------------------------------------------------------------------------------------------------

		Column(std::ifstream& in);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Перегрузка оператора ввода из файл
    //!
    //! \param in           файловый поток
    //! \param header       вводимый объект класса
    //-----------------------------------------------------------------------------------------------------------

		friend
			std::ifstream& operator>>(std::ifstream& in, Column& header);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Перегрузка оператора вывода в файл
    //!
    //! \param out          файловый поток
    //! \param header       выводимый объект класса
    //-----------------------------------------------------------------------------------------------------------

		friend
			std::ofstream& operator<<(std::ofstream& out, const Column& header);
	};

//===============================================================================================================
//! \class Element
//! \brief Элемент таблицы
//---------------------------------------------------------------------------------------------------------------

	class Element
	{
	public:
		typedef std::variant<Time, uint8_t, uint16_t, int, long, long long,
			unsigned int, unsigned long, unsigned long long, float, double, 
            long double, std::string> types;    ///< тип данных, в котором хранитмя значение элемента таблицы

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Конструктор по-умолчанию
    //-----------------------------------------------------------------------------------------------------------

		Element();

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Консруктор с получением значения
    //!
    //! \param type         тип хранимых данных
    //! \param value        значение ячейки, которое будет преобразованно в соответствуюший тип
    //-----------------------------------------------------------------------------------------------------------

		template<class T>
		Element(parsing_type type, T value);
    
    //-----------------------------------------------------------------------------------------------------------
    //! \brief Установка значения элемента таблицы
    //!
    //! \param type         тип хранимых данных
    //! \param value        значение ячейки, соответствующего типа
    //-----------------------------------------------------------------------------------------------------------

		template<class T>
		void set(parsing_type type, T value);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Задание нового значения элементу
    //!
    //! \param value        значение ячейки
    //!
    //! \warning если тип переменной не будет соответсовать текущему типу элемента, будет пропрошено исключение
    //-----------------------------------------------------------------------------------------------------------

        template<class T>
        void operator=(T value);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Получение значения элемента таблицы
    //!
    //! \return указатель на значение элемента соответствующего типа
    //-----------------------------------------------------------------------------------------------------------

		const void* get() const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Получение типа хранения данных
    //!
    //! \return тип хранения данных
    //-----------------------------------------------------------------------------------------------------------

		parsing_type get_type() const;
    
    //-----------------------------------------------------------------------------------------------------------
    //! \brief ПОлучение значения элемента таблицы, как строки
    //!
    //! \return строка со значением элемента
    //-----------------------------------------------------------------------------------------------------------

	    std::string as_string() const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор меньше
    //!
    //! \param el           объект класса, с ктороым сравниваем
    //!
    //! \return результат сравнения
    //-----------------------------------------------------------------------------------------------------------

		bool operator<(const Element& el) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор меньше или равно
    //!
    //! \param el           объект класса, с ктороым сравниваем
    //!
    //! \return результат сравнения
    //-----------------------------------------------------------------------------------------------------------

		bool operator<=(const Element& el) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор больше
    //!
    //! \param el           объект класса, с ктороым сравниваем
    //!
    //! \return результат сравнения
    //-----------------------------------------------------------------------------------------------------------

		bool operator> (const Element& el) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор больше или равно
    //!
    //! \param el           объект класса, с ктороым сравниваем
    //!
    //! \return результат сравнения
    //-----------------------------------------------------------------------------------------------------------

		bool operator>=(const Element& el) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор равенства
    //!
    //! \param el           объект класса, с ктороым сравниваем
    //!
    //! \return результат сравнения
    //-----------------------------------------------------------------------------------------------------------

		bool operator==(const Element& el) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор не равенства
    //!
    //! \param el           объект класса, с ктороым сравниваем
    //!
    //! \return результат сравнения
    //-----------------------------------------------------------------------------------------------------------

		bool operator!=(const Element& el) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Оператор равенства значений элемента
    //!
    //! \param val          значение с которым
    //!
    //! \return результат сравнения
    //-----------------------------------------------------------------------------------------------------------

        template<class T>
        bool operator==(const T& val) const;

	private:
		types _value;           ///<    значение элемента
		parsing_type _type;     ///<    тип хранимого значения
	};

//===============================================================================================================
//! \class DataBase
//! \brief Класс для получения и работы с таблицой, основанный на классу CSV_table
//---------------------------------------------------------------------------------------------------------------

	class DataBase : public csv_format::CSV_table<Element, Column>
	{
	public:

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Конструктор по-умолчанию
    //!
    //! \param separator    разделить данных в таблице
    //-----------------------------------------------------------------------------------------------------------

		DataBase(char separator = '|');

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Конструктор из файла
    //!
    //! \param in           файловый поток
    //! \param separator    разделить данных в таблице
    //-----------------------------------------------------------------------------------------------------------

		DataBase(std::ifstream& in, char separator = '|');
    
    //-----------------------------------------------------------------------------------------------------------
    //! \brief Сортирует баззу данных по заданому столбцу
    //!
    //! \param column       имя столбца, по которому сортируем
    //! \param sort         функция сортировки
    //-----------------------------------------------------------------------------------------------------------

		void sort(std::string column = "", void (*sort)(std::vector<Row>::iterator first, std::vector<Row>::iterator last,
			bool (*cmp)(const Row& row1, const Row& row2)) = std::sort);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Перегрузка оператора вывода на экран
    //!
    //! \param out          поток вывода
    //! \param bd           выводимый объект класса
    //-----------------------------------------------------------------------------------------------------------

		friend
			std::ostream& operator<<(std::ostream& out, const DataBase& bd);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Перегрузка оператора вывода в файла
    //!
    //! \param out          файловый поток
    //! \param bd        выводимый объект класса
    //-----------------------------------------------------------------------------------------------------------

		friend
			std::ofstream& operator<<(std::ofstream& out, const DataBase& bd);

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Перегрузка оператора ввода из файла
    //!
    //! \param in           файловый поток
    //! \param bd           вводимый объект класса
    //-----------------------------------------------------------------------------------------------------------

		friend
			std::ifstream& operator>>(std::ifstream& in, DataBase& bd);


	private:

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Вывод разделяющей строки линии
    //!
    //! \param out          файловый поток
    //-----------------------------------------------------------------------------------------------------------

		void print_divide_line(std::ostream& out) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Вывод заголовка таблицы
    //!
    //! \param out          файловый поток
    //-----------------------------------------------------------------------------------------------------------

		void print_column(std::ostream& out) const;

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Вывод всей таблицы
    //!
    //! \param out          файловый поток
    //-----------------------------------------------------------------------------------------------------------

		void print_table(std::ostream& out) const;

		static size_t _sort_id;         ///< номер столбца по которому происходит сортировка

    //-----------------------------------------------------------------------------------------------------------
    //! \brief Функция сравнения двух строк во время сортировки
    //!
    //! \param row1          первая строка
    //! \param row1          вторая строка
    //-----------------------------------------------------------------------------------------------------------

		static bool comparator(const Row& row1, const Row& row2);
	};

//=================================================================================================================

    template<class T>
    inline Element::Element(DB::parsing_type type, T value)
        : Element()
    {
        set(type, value);
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class T>
    inline void Element::set(DB::parsing_type type, T value)
    {
        bool bad = false;
        switch (type)
        {
        case DB::parsing_type::UInt8:
            if (typeid(value) != typeid(uint8_t)) bad = true;
            break;
        case DB::parsing_type::UInt16:
            if (typeid(value) != typeid(uint16_t)) bad = true;
            break;
        case DB::parsing_type::Int32:
            if (typeid(value) != typeid(int)) bad = true;
            break;
        case DB::parsing_type::Long:
            if (typeid(value) != typeid(long)) bad = true;
            break;
        case DB::parsing_type::LLong:
            if (typeid(value) != typeid(long long)) bad = true;
            break;
        case DB::parsing_type::UInt:
            if (typeid(value) != typeid(unsigned int)) bad = true;
            break;
        case DB::parsing_type::ULong:
            if (typeid(value) != typeid(unsigned long)) bad = true;
            break;
        case DB::parsing_type::ULLong:
            if (typeid(value) != typeid(unsigned long long)) bad = true;
            break;
        case DB::parsing_type::Float:
            if (typeid(value) != typeid(float)) bad = true;
            break;
        case DB::parsing_type::Double:
            if (typeid(value) != typeid(double)) bad = true;
            break;
        case DB::parsing_type::LDouble:
            if (typeid(value) != typeid(long double)) bad = true;
            break;
        case DB::parsing_type::String:
            if (typeid(value) != typeid(std::string)) bad = true;
            break;
        case DB::parsing_type::Date:
            if (typeid(value) != typeid(Time)) bad = true;
            break;
        default:
            _type = parsing_type::NoType;
            _value = 0;
            return;
        }

        if (bad)
        {
            throw std::invalid_argument("Type of argument not equal geted type");
        }

        _type = type;
        _value = value;
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class T>
    inline void Element::operator=(T value)
    {
        set(_type, value);
    }

//-----------------------------------------------------------------------------------------------------------------

    template<class T>
    inline bool Element::operator==(const T& val) const
    {
        types tmp = val;
        return _value == tmp;
    }

//-----------------------------------------------------------------------------------------------------------
//! \brief Установка значения элемента
//!
//! \param type         тип хранимых данных
//! \param value        строка со значением, будет преобразована в заданный тип
//-----------------------------------------------------------------------------------------------------------

    template<>
    inline void Element::set(DB::parsing_type type, std::string value)
    {
        _type = type;
        if (type == DB::parsing_type::UInt8)
        {
            uint8_t a = 0;
            a << value;
            _value = a;
            return;
        }
        if (type == DB::parsing_type::UInt16)
        {
            uint16_t a = 0;
            a << value;
            _value = a;
            return;
        }
        if (type == DB::parsing_type::Int32)
        {
            int a = 0;
            a << value;
            _value = a;
            return;
        }
        if (type == DB::parsing_type::Long)
        {
            long a = 0;
            a << value;
            _value = a;
            return;
        }
        if (type == DB::parsing_type::LLong)
        {
            long long a = 0;
            a << value;
            _value = a;
            return;
        }
        if (type == DB::parsing_type::UInt)
        {
            unsigned int a = 0;
            a << value;
            _value = a;
            return;
        }
        if (type == DB::parsing_type::ULong)
        {
            unsigned long a = 0;
            a << value;
            _value = a;
            return;
        }
        if (type == DB::parsing_type::ULLong)
        {
            unsigned long long a = 0;
            a << value;
            _value = a;
            return;
        }
        if (type == DB::parsing_type::Float)
        {
            float a = 0;
            a << value;
            _value = a;
            return;
        }
        if (type == DB::parsing_type::Double)
        {
            double a = 0;
            a << value;
            _value = a;
            return;
        }
        if (type == DB::parsing_type::LDouble)
        {
            long double a = 0;
            a << value;
            _value = a;
            return;
        }
        if (type == DB::parsing_type::String)
        {
            _value = value;
            return;
        }
        if (type == DB::parsing_type::Date)
        {
            DB::Time a = 0;
            a << value;
            _value = a;
            return;
        }

        _type = DB::parsing_type::NoType;
        _value = 0;
    }
}